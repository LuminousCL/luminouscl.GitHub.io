---
title:  DP题型总结
tags:
  - 算法
---

<img src="/assets/image/2020-11-03.jpg" width="100%" height="100%" div align=center>

秋招告一段落，感谢一直没有放弃的自己，感谢所有给我鼓励和帮助的人。

相信奇迹的人，本身就和奇迹一样了不起。

<br/>

### DP题型总结



### 86. Longest Ascending Subarray

Given an unsorted array, find the length of the longest subarray in which the numbers are in ascending order.

**Clarification:** The input is an int[] array which is unsorted, and the output should be the length of the longest ascending subarray.

**Assumption:** The given array is not null.

**Result:** Firstly we should check the corner case: array.length == 0;

then we use int[] M to achieve the DP, and mantain a globalmax to record the outcome.

**Base case:** M[0] = 1; the first number itself is an ascending subarray.

**Induction rule:** M[i] = ascending? M[i - 1] + 1: 1.

**Test:** {7, 2, 3, 1, 5, 8, 9, 6}, longest ascending subarray is {1, 5, 8, 9}, length is 4.

```java
public class Solution {
  public int longest(int[] array) {
    if (array.length == 0) {
      return 0;
    }
    int[] M = new int[array.length];
    int globalMax = 1;
    M[0] = 1; 
    for (int i = 1; i < array.length; i++) {
      M[i] = array[i] > array[i - 1]? M[i - 1] + 1 : 1;
      globalMax = Math.max(globalMax, M[i]);
    }
    return globalMax;
  }
}
```

|       Time Complexity       |       Space Complexity       |
| :-------------------------: | :--------------------------: |
|            O(n)             |             O(n)             |
| 一个for循环go over一遍array | DP的问题需要记录下之前的结果 |





### 87. Max Product Of Cutting Rope

Given a rope with positive integer-length *n*, how to cut the rope into *m* integer-length parts with length *p*[0], *p*[1], ...,*p*[*m*-1], in order to get the maximal product of *p*[0]**p*[1]* ... **p*[*m*-1]? *m* **is determined by you** and must be greater than 0 **(at least one cut must be made**). Return the max product you can have.

**Clarification:** The input is an integer which is the rope's length, and the output should also be the integer of max product.

**Assumption:** The given array is not null and n >= 2(n < 2不make sense).

**Result:** Firstly we should check the corner case: array.length < 2;

then we use int[] M to achieve the DP, 切绳子的**左大段 + 右小段**思想，右边小段(j, i)不可分；

**Base case:** M[0] = 0; M[1] = 0; the index i start from 2 and index j start from 1;

**Induction rule:** M[i] = Math.max(M[i], 在j处切：Math.max(j: 左大段不切，M[j]) * (i - j)右小段).

**Test:** {n = 12, the max product is 3 * 3 * 3 * 3 = 81(cut the rope into 4 pieces with length of each is 3).

```java
public class Solution {
  public int maxProduct(int length) {
    if (length < 2) {
      return 0;
    }
    int[] M = new int[length + 1]; // 割绳子类似string问题，DP的长度都+1
    M[1] = 0;
    for (int i = 2; i <= length; i++) {
      for (int j = 1; j < i; j++) {
        M[i] = Math.max(M[i], Math.max(j, M[j]) * (i - j));
      }
    }
    return M[length];
  }
}
```

|       Time Complexity       |       Space Complexity       |
| :-------------------------: | :--------------------------: |
|           O(n^2)            |             O(n)             |
| 两个for循环go over一遍array | DP的问题需要记录下之前的结果 |





### 88. Array Hopper I

Given an array A of non-negative integers, you are initially positioned at index 0 of the array. **A[i] means the maximum jump distance from that position (you can only jump towards the end of the array).** Determine if you are able to reach the last index.

**Clarification:** The input is an int[] array, and the output should be the boolean representing whether we can jump to the end of array from the start.

**Assumption:** The given array is not null and has the length at least 1.

**Result:** Firstly we should check the corner case: array.length <= 1;

then we use int[] M to achieve the DP, 从左到右的常规DP.

**Base case:** M[0] = true; we can always jump to the end from start if they are the same.

**Induction rule:** two for loop; index i start from 0, index j start from 0 representing whether we can get the j before i and jump to the i from j; if we get M[i] = true, we can break the for loop.

**Test:** {1, 3, 2, 0, 3}, we are able to reach the end of array(jump to index 1 then reach the end of the array).

```java
public class Solution {
  public boolean canJump(int[] array) {
    if (array.length <= 1) {
      return true;
    }
    boolean[] M = new boolean[array.length];
    M[0] = true;
    for (int i = 0; i < array.length; i++) {
      for (int j = 0; j < i; j++) {
        if (M[j] && array[j] + j >= i) {
          M[i] = true;
          break;
        }
      }
    }
    return M[array.length - 1];
  }
}
```

|       Time Complexity       |       Space Complexity       |
| :-------------------------: | :--------------------------: |
|           O(n^2)            |             O(n)             |
| 两个for循环go over一遍array | DP的问题需要记录下之前的结果 |





### 89. Array Hopper II

Given an array A of non-negative integers, you are initially positioned at index 0 of the array. **A[i] means the maximum jump distance from index i (you can only jump towards the end of the array).** Determine the minimum number of jumps you need to reach the end of array. If you can not reach the end of the array, return -1.

**Clarification:** The input is an int[] array, and the output should be integer representing the number of minumum jumps from start to the end of array.

**Assumption:** The given array is not null and has the length at least 1.

**Result:** Firstly we should check the corner case: array.length <= 1;

then we use int[] M to achieve the DP, 从左到右的常规DP.

**Base case:** M[0] = 0; we don't need to jump and can directly jump to the end.

**Induction rule:** two for loop.

**Test:** {1, 3, 2, 0, 3}, we are able to reach the end of array(jump to index 1 then reach the end of the array).

```java
public class Solution {
  public int minJump(int[] array) {
    if (array.length <= 1) {
      return 0;
    }
    int[] M = new int[array.length];
    M[0] = 0;
    for (int i = 1; i < array.length; i++) {
      M[i] = -1;
      for (int j = 0; j < i; j++) {
        if (j + array[j] >= i && M[j] != -1) {
          if (M[i] == -1 || M[i] > M[j] + 1) {
            M[i] = M[j] + 1;
          }
        }
      }
    }
    return M[array.length - 1];
  }
}
```

|       Time Complexity       |       Space Complexity       |
| :-------------------------: | :--------------------------: |
|           O(n^2)            |             O(n)             |
| 两个for循环go over一遍array | DP的问题需要记录下之前的结果 |





### 97. Largest Subarray Sum

Given an unsorted integer array, find the **subarray** that has the greatest sum. Return the sum.

**Clarification:** The input is an int[] array, and the output should be integer representing the sum of the largest subarray.

**Assumption:** The given array is not null and has the length at least 1.

**Result:** Firstly we should check the corner case: array.length <= 1;

then we use int[] M to achieve the DP, and maintain a globalMax to record.

**Base case:** M[0] = array[0]; when array.length == 1, the largest subarray sum is the number itself.

**Induction rule:** M[i] = max(M[i - 1] + array[i]; array[i] (另起炉灶)).

**Test:** {2, -1, 4, -2, 1}, the largest subarray sum is 2 + (-1) + 4 = 5.

```java
public class Solution {
  public int largestSum(int[] array) {
    if (array.length <= 1) {
      return array[0];
    }
    int[] M = new int[array.length];
    M[0] = array[0];
    int globalMax = array[0];
    for (int i = 1; i < array.length; i++) {
      M[i] = Math.max(M[i - 1] + array[i], array[i]);
      globalMax = Math.max(M[i], globalMax);
    }
    return globalMax;
  }
}
```

|       Time Complexity       |       Space Complexity       |
| :-------------------------: | :--------------------------: |
|            O(n)             |             O(n)             |
| 一个for循环go over一遍array | DP的问题需要记录下之前的结果 |





### 489. Quiz:Largest Subarray Sum

Given an unsorted integer array, find the subarray that has the greatest sum. Return the sum and the indices of the left and right boundaries of the subarray. If there are multiple solutions, return the leftmost subarray.

**Clarification:** The input is an int[] array, and the output should also be an int[] array, which contains the sum and left & right index, n a array as [sum, left, right].

**Assumption:** The given array is not null and has the length at least 1.

**Result:** Firstly we should check the corner case: array.length < 1;

we should maintain four temp variables: cur_left, cur_right, global_left, global_right.

case 1: if (M[i - 1] < 0) cur_left  and cur_right should be reset to the i;

case 2: else: cur_right++;

case 3:if (globalMax is updated) we should set global_left to cur_left, cur_right = global_right;

case 4: globalMax = Math.max(M[i], globalMax).

**Base case:** M[0] = array[0]; when array.length == 1, the largest subarray sum is the number itself.

**Induction rule:** M[i] = max(M[i - 1] + array[i]; array[i] (另起炉灶)).

**Test:** {2, -1, 4, -2, 1}, the largest subarray sum is 2 + (-1) + 4 = 5. The indices of the left and right boundaries are 0 and 2, respectively.

```java
public class Solution {
  public int[] largestSum(int[] array) {
    if (array.length <= 1) {
      return new int[]{array[0], 0, 0};
    }
    int[] M = new int[array.length];
    M[0] = array[0];
    int cur_left = 0;
    int cur_right = 0;
    int global_left = 0;
    int global_right = 0;
    int globalMax = array[0];
    for (int i = 1; i < array.length; i++) {
      M[i] = Math.max(M[i - 1] + array[i], array[i]);   
      if (M[i - 1] < 0) {
        cur_left = cur_right = i;
      }
      else {
        cur_right++;
      }
      if (globalMax < M[i]) {
        global_left = cur_left;
        global_right = cur_right;
      }
      globalMax = Math.max(M[i], globalMax);
    }
    return new int[]{globalMax, global_left, global_right};
  }
}
```

|       Time Complexity       |       Space Complexity       |
| :-------------------------: | :--------------------------: |
|            O(n)             |             O(n)             |
| 一个for循环go over一遍array | DP的问题需要记录下之前的结果 |





### 99. Dictionary Word I

Given a word and a dictionary, determine if it can be composed by concatenating words from the given dictionary.

**Clarification:** The inputs are a String[] dict and a String input, and the output should be a boolean shows whether we can split the String and all parts are contained in the dictionary.

**Assumption:** The given word is not null and not empty; the given dictionary is not null and not empty; and all the words in the dictionary are not null  and not empty.

**Result:** We don't need to check the corner case;

we use int[] M to achieve the DP, M[i] represents if we can split the String from 0 to index i;

pre-preocessing: we need to create a set and put all words in String[] into the set.

**Base case:** M[0] = true; if there is a space only, we can think it is true.

**Induction rule:** M[i] = true when M[j] == true && dictionary contains(input.substring(j, i)), and this for loop break.

**Test:** Dictionary: {“bob”, “cat”, “rob”}; 

Word: “robob” return false

Word: “robcatbob” return true since it can be composed by "rob", "cat", "bob".

```java
public class Solution {
  public boolean canBreak(String input, String[] dict) {
    Set<String> dictSet = toSet(dict);
    boolean[] M = new boolean[input.length() + 1]; // string问题，DP的长度都+1
    M[0] = true;
    for (int i = 1; i <= input.length(); i++) {
      for (int j = 0; j < i; j++) {
        if (M[j] && dictSet.contains(input.substring(j, i))) {
          M[i] = true;
          break;
        }
      }
    }
    return M[input.length()];
  }

  private Set<String> toSet(String[] dict) {
    Set<String> set = new HashSet<>();
    for (String s: dict) {
      set.add(s);
    }
    return set;
  }
}
```

|       Time Complexity       |       Space Complexity       |
| :-------------------------: | :--------------------------: |
|           O(n^2)            |             O(n)             |
| 两个for循环go over一遍array | DP的问题需要记录下之前的结果 |





### 143. Minimum cuts for Palindromes

Given a string, a partitioning of the string is a *palindrome partitioning* if every substring of the partition is a palindrome. Determine the **fewest** cuts needed for a palindrome partitioning of a given string.

**Clarification:** The input is a String, the output should be a integer shows the minumum cuts to let all parts of the String to be a palindrome.

**Assumption:** The given string is not null.

**Result:** Firstly we should check the corner case: input == null || input.length() <= 1 --> return 0;

we use int[] M to achieve the DP, M[i] represents the minumum cuts we can split the String from 0 to index i which all parts are palindromes;

pre-preocessing: we need to create a method to determine whether a word is a palindrome.

**Base case:** M[0] = 0; if there is a space only, we don't need to cut;

M[1] = 0; if there is only one character, it is palindrome and we also don't need to cut.

**Induction rule:** M[i] = M[j] + 1 when substring(j, i) is a palindrome && M[i] > M[j] + 1.

**Test:** “a | babbbab | bab | aba” is a palindrome partitioning of “ababbbabbababa”.

The minimum number of cuts needed is 3.

```java
public class Solution {
  public int minCuts(String input) {
    if (input == null || input.length() <= 1) {
      return 0;
    }
    int[] M = new int[input.length() + 1];
    M[0] = 0;
    M[1] = 0;
    for (int i = 2; i <= input.length(); i++) {
      if (isValid(input.substring(0, i))) {
        M[i] = 0;
        continue;
      }
      M[i] = Integer.MAX_VALUE;
      for (int j = 1; j < i; j++) {
        if (isValid(input.substring(j, i)) && M[j] + 1 < M[i]) {
          M[i] = M[j] + 1;
        }
      }
    }
    return M[input.length()];
  }

  private boolean isValid(String input) {
    if (input.length() <= 1) {
      return true;
    }
    int i = 0;
    int j = input.length() - 1;
    while (i < j) {
      if (input.charAt(i) != input.charAt(j)) {
        return false;
      }
      i++;
      j--;
    }
    return true;
  }
}

```

|                  Time Complexity                  |       Space Complexity       |
| :-----------------------------------------------: | :--------------------------: |
|                      O(n^3)                       |             O(n)             |
| 两个for循环go over一遍array, isValid一个while循环 | DP的问题需要记录下之前的结果 |





### 100. Edit Distance

Given two strings of alphanumeric characters, determine the minimum number of **Replace**, **Delete**, and **Insert** operations needed to transform one string into the other.

**Clarification:** The input is two Strings, and the output should be a integer shows the minumum numbers to transfer one string to another.

**Assumption:** Both strings are not null.

**Result:**  We don't need to check the corner case because both strings are not null;

for each step, we grow the string from left hand side to the right hand side;

we  use int[][] [] [] M to achieve the DP; M[i] [j] represents the minimum number of actions to transform the first i letter of S1 to the first j letter of S2;

we use int[] M to achieve the DP, M[i] represents the minumum cuts we can split the String from 0 to index i which all parts are palindromes;

<img src="/Users/arthur/Library/Application Support/typora-user-images/image-20200511114914559.png" alt="image-20200511114914559" style="zoom:50%;" />

<img src="/Users/arthur/Library/Application Support/typora-user-images/image-20200511114940751.png" alt="image-20200511114940751" style="zoom:50%;" />

**Base case:** 

a. M[0] [0] = 0;  

b. M[i] [0] = i;

c. M[0] [j] = j.

**Induction rule:** 

a. M[i] [j] represents the minimum number of actions to transform the first i letters of S1(s1[0...i - 1]) to the first j letters of S2(s2[0...j - 1]).

b. M[i] [j] = M[i - 1] [j - 1]                                                           if s1[i - 1] = s2[j - 1]

​                    min(M[i - 1] [j - 1], M[i - 1] [j], M[i] [j - 1]) + 1      otherwise



**Test:** String one: “sigh”, string two : “asith”

the edit distance between one and two is 2 (one insert “a” at front then replace “g” with “t”).

```java
public class Solution {
  public int editDistance(String one, String two) {
    int[][] M = new int[one.length() + 1][two.length() + 1];
    for (int i = 0; i <= one.length(); i++) {
      for (int j = 0; j <= two.length(); j++) {
        if (i == 0) {
          M[i][j] = j;
        }
        else if (j == 0) {
          M[i][j] = i;
        }
        else if (one.charAt(i - 1) == two.charAt(j - 1)) {
          M[i][j] = M[i - 1][j - 1];
        }
        else {
          M[i][j] = Math.min(M[i - 1][j] + 1, M[i][j - 1] + 1);
          M[i][j] = Math.min(M[i - 1][j - 1] + 1, M[i][j]);
        }
      }
    }
    return M[one.length()][two.length()];
  }
}
```

|                  Time Complexity                  |       Space Complexity       |
| :-----------------------------------------------: | :--------------------------: |
|                       O(mn)                       |            O(mn)             |
| 两个for循环go over一遍array, isValid一个while循环 | DP的问题需要记录下之前的结果 |





### 101. Largest Square Of 1s

Determine the largest square of 1s in a binary matrix (a binary matrix only contains 0 and 1), return the length of the largest square.

**Clarification:** The input is a 2D int[][][] [] matrix, and the output should be an integer represents the length of largest square.

**Assumption:** The given matrix is not null and guaranteed to be of size N * N, N >= 0.

**Result:**  We use the same idea as before to maintain an 2D int[] [] matrix.

If matrix.length or matrix[0].length == 0, we can only trturn 0.

We  use int[][] [] [] M to achieve the DP; M[i] [j] represents the max size of square with (i, j) as the bottom right corner.

**Base case:** 

a. M[0] [0] = 0;  

b. if i == 0. M[i] [j] = matrix[i] [j]  (1 / 0)

c. if j == 0  M[i] [j] =  matrix[i] [j]. (1 / 0)

**Induction rule:** 

a. M[i] [j] represents the max size of square with(i, j) as the bottom right corner.

b. M[i] [j] = 0                                                                                if A[i] [j] == 0

​                    min(M[i - 1] [j - 1], M[i - 1] [j], M[i] [j - 1]) + 1      otherwise

**Test:** 

{ {0, 0, 0, 0},

 {1, **1, 1,** 1},

 {0, **1, 1,** 1},

 {1, 0, 1, 1}}

the largest square of 1s has length of 2.

```java
public class Solution {
  public int largest(int[][] matrix) {
    int N = matrix.length;
    if (N == 0) {
      return 0;
    }
    
    int result = 0; // globalMax
    // M[i][j] means the largest square of 1's with right bottom
    int[][] M = new int[N][N];
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        if (i == 0 || j == 0) {
          M[i][j] = matrix[i][j] == 1? 1: 0;
        }
        else if (matrix[i][j] == 1) {
          M[i][j] = Math.min(M[i - 1][j] + 1, M[i][j - 1] + 1);
          M[i][j] = Math.min(M[i - 1][j - 1] + 1, M[i][j]);
        }
        result = Math.max(result, M[i][j]);
      }
    }
    return result;
  }
}
```

|          Time Complexity          |    Space Complexity     |
| :-------------------------------: | :---------------------: |
|              O(n^2)               |         O(n^2)          |
| 两个for loop循环一遍；每次循环是n | 填满2D M[i] [j]的matrix |





### 1. Longest Ascending Subsequence

Given an array A[0]...A[n-1] of integers, find out the length of the longest ascending subsequence.

**Clarification:** The input is an array of integers, and the output is the length of longest ascending subsequence.

**Assumption:** A is not null.

**Result:**  

**Base case:** M[0] = 1.

**Induction rule:** M[i] represents from the 0-th element to the i-th element, the value(length) of the longest ascending subarray (including the i-th element).

M[i] = max{M[j]} + 1                    if a[i] < a[j] and 0 <= j < i

​           1                                          if there is no such j

**Test:** 

Input: A = {5, 2, 6, 3, 4, 7, 5}
Output: 4
Because [2, 3, 4, 5] is the longest ascending subsequence.

```java
public class Solution {
  public int longest(int[] array) {
    // Method 1: O(n^2)
    // Assumptions; array is not null.
    if (array.length == 0) {
      return 0;
    }

    // M[i] = the length of longest ascending subsequence 
    // ending at index i.
    int[] M = new int[array.length];
    // record the length of longest subsequence so far.
    int result = 1;
    for (int i = 0; i < array.length; i++) {
      // initialize <[i] as 1, since the shortest one has length 1,
      // just array[i] itself.
      M[i] = 1;
      for (int j = 0; j < i; j++) {
        // only when array[j] < array[i], it is possible to use the
        // longest ascending subsequence ending at index j and array[i]
        // to form a new ascending subsequence.
        if (array[j] < array[i]) {
          M[i] = Math.max(M[j] + 1, M[i]);
        } 
      }
      // possibly update the global longest one.
      result = Math.max(M[i], result);
    }
    return result;
  }
}
```

|          Time Complexity          |       Space Complexity       |
| :-------------------------------: | :--------------------------: |
|              O(n^2)               |             O(n)             |
| 两个for loop循环一遍；每次循环是n | DP的问题需要记录下之前的结果 |





### 683. Count Ascending Subsequence

Given an array A[0]...A[n-1] of integers, count the number of ascending subsequences.

In case that the result is larger than 32-bit integer, return the result in 10^9+7 modulo.

**Clarification:** The input is an array of integers, and the output is the number of ascending subsequences.

**Assumption:** A is not null.

**Result:**  Firstly we should check the corner case: if a.length == 0, we should return 0.

**Base case:** M[0] = 1.

**Induction rule:** M[i] represents the number of ascending subsequences that end at a[i].

M[i] = (Sum(M[j]) when a[j] < a[i]) + 1

**Test:** 

Input: A = {1,2,3}
Output: 7
Explanation: [1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]

```java
public class Solution {
  public int numIncreasingSubsequences(int[] a) {
    if (a.length == 0) {
      return 0;
    }

    int[] M = new int[a.length];
    M[0] = 1;
    for (int i = 1; i < a.length; i++) {
      M[i]++;
      for (int j = 0; j < i; j++) {
        if (a[j] < a[i]) {
          M[i] += M[j];
        }
      }
    }
    int result = 0;
    for (int i = 0; i < a.length; i++) {
      result += M[i];
    }
    return result;
  }
}
```

|          Time Complexity          |       Space Complexity       |
| :-------------------------------: | :--------------------------: |
|              O(n^2)               |             O(n)             |
| 两个for loop循环一遍；每次循环是n | DP的问题需要记录下之前的结果 |





### 217. Largest Set Of Points With Positive Slope

Given an array of 2D coordinates of points (all the coordinates are integers), find the largest number of points that can form a set such that any pair of points in the set can form a line with positive slope. Return the size of such a maximal set.

**Clarification:** The input is an array of integers, we should create the class of point, and the output is the number of largest set of points.

**Assumption:** A is not null.

If there does not even exist 2 points can form a line with positive slope, should return 0.

**Result:**  

**Base case:** M[0] = 0.

**Induction rule:** 

P1<x1, y1>. P2<x2, y2>

slope =  (y2 - y1) / (x2 - x1) > 0

when x2 > x1, we must have y2 > y1.

The question can be converted to the **LONGEST ASCENDING SUB-SEQUENCE.**

Step 1: Sort the input points according to their x-coordinates. Result is put to A[N].                  Time O(nlogn)

Step 2: A[N] = {<x0, y0>, <x1, y1>, <x2, y2> ... <xn-1, yn-1>}

​			 Find the longest ascending sub-sequence in A[N] according to their y-coordinates.      Time O(nlogn)

**Test:** 

<0, 0>, <1, 1>, <2, 3>, <3, 3>, the maximum set of points are {<0, 0>, <1, 1>, <2, 3>}, the size is 3.

```java
/*
* class Point {
*   public int x;
*   public int y;
*   public Point(int x, int y) {
*     this.x = x;
*     this.y = y;
*   }
* }
*/
public class Solution {
  public int largest(Point[] points) {
    // Assumptions: points is not null.
    // we need to sort the points by x ascending and y descending.
    Arrays.sort(points, new MyComparator());
    // similar to longest ascending subsequence.
    int result = 1;
    int[] M = new int[points.length];
    for (int i = 0; i < M.length; i++) {
      M[i] = 1;
      for (int j = 0; j < i; j++) {
        if (points[j].y < points[i].y) {
          M[i] = Math.max(M[i], M[j] + 1);
        }
      }
      result = Math.max(result, M[i]);
    }
    return result == 1? 0 : result;
  }

  // this comparator will sort the point by x ascending and y descending.
  static class MyComparator implements Comparator<Point> {
    @ Override
    public int compare(Point p1, Point p2) {
      return p1.x != p2.x ? p1.x - p2.x : p2.y - p1.y;
    }
  }
}
```

|            Time Complexity            |       Space Complexity       |
| :-----------------------------------: | :--------------------------: |
|             O((nlogn)^2)              |             O(n)             |
| 两个for loop循环一遍；每次循环是nlogn | DP的问题需要记录下之前的结果 |





### 176. Longest Common Substring

Find the longest common substring of two given strings.

**Clarification:** The inputs are String source and String target, and the output is the common substring of two given strings.

**Assumption:** The two given strings are not null.

**Result:**  Firstly we should make two pre-processing:

a. String.toCharArray();

b. int start and int longest to record the head and the length of the common substring.

**Base case:** 

a. M[0] [0] = 0

b. M[i] [0] = 0

c. M[0] [j] = 0

**Induction rule:** 

M[i] [j] = 1 + M[i - 1] [j - 1]                                   if a[i - 1] == b[j - 1]

​               0                                                               if a[i - 1] != b[j - 1]

**Test:** 

S = “abcde”, T = “cdf”, the longest common substring of S and T is “cd”

```java
public class Solution {
  public String longestCommon(String source, String target) {
    // Assumptions: source, target are not null.
    char[] sa = source.toCharArray();
    char[] ta = target.toCharArray();

    // record the longest common substring's start position in source.
    int start = 0;
    // record the longest common substring's length.
    int longest = 0;
    int[][] M = new int[sa.length][ta.length];
    for (int i = 0; i < sa.length; i++) {
      for (int j = 0; j < ta.length; j++) {
        if (sa[i] == ta[j]) {
          if (i == 0 || j == 0) {
            M[i][j] = 1;
          }
          else {
            M[i][j] = M[i - 1][j - 1] + 1;
          }
          if (M[i][j] > longest) {
            longest = M[i][j];
            start = i - longest + 1;
          }
        }
      }
    }
    return source.substring(start, start + longest);
  }
}
```

|             Time Complexity              |    Space Complexity     |
| :--------------------------------------: | :---------------------: |
|                  O(mn)                   |          O(mn)          |
| 两个for loop循环一遍；循环长度分别为m和n | 填满2D M[i] [j]的matrix |





### 177. Longest Common Sequence

Find the length of longest common subsequence of two given strings.

**Clarification:** The inputs are String source and String target, and the output is the length of two given strings' common subsequence.

**Assumption:** The two given strings are not null.

**Result:**  

**Base case:** 

a. M[0] [0] = 0

b. M[i] [0] = 0

c. M[0] [j] = 0

**Induction rule:** 

M[i] [j] = 1 + M[i - 1] [j - 1]                                   if a[i - 1] == b[j - 1]

​                max (M[i - 1] [j], M[i] [j - 1])                 Otherwise

**Test:** 

S = “abcde”, T = “cbabdfe”, the longest common subsequence of s and t is {‘a’, ‘b’, ‘d’, ‘e’}, the length is 4.

```java
public class Solution {
  public int longest(String source, String target) {
    // Assumptions: source, target are not null.
    // using the trick of "add 1" index, will make the base case
    // easier to handle, e.g. the 0th row and the 0th column will
    // be all zero.
    int[][] M = new int[source.length() + 1][target.length() + 1];
    for (int i = 1; i <= source.length(); i++) {
      for (int j = 1; j <= target.length(); j++) {
        if (source.charAt(i - 1) == target.charAt(j - 1)) {
          M[i][j] = M[i - 1][j - 1] + 1;
        }
        else {
          M[i][j] = Math.max(M[i - 1][j], M[i][j - 1]);
        }
      }
    }
    return M[source.length()][target.length()];
  }
}
```

|             Time Complexity              |    Space Complexity     |
| :--------------------------------------: | :---------------------: |
|                  O(mn)                   |          O(mn)          |
| 两个for loop循环一遍；循环长度分别为m和n | 填满2D M[i] [j]的matrix |





### 137. Cutting Wood I

There is a wooden stick with length L >= 1, we need to cut it into pieces, where the cutting positions are defined in an int array A. The positions are guaranteed to be in ascending order in the range of [1, L - 1]. The cost of each cut is the length of the stick segment being cut. Determine the minimum total cost to cut the stick into the defined pieces.

中文题意：有一个长为L米的木料需要割开，需要切的位置在一个数组里A[0...N]，**从一个地方切开的cost是当前所切木料的长度。按不同的顺序切割，** 得到的total cost是不一样的，问怎么切cost最小。比如一个木料现在是10米长，然后切的位置是2米处，4米处和7米处（就是说array A里A[1] 是2，A[2]是4，A[3]是7）。那么比如先切2米，得到的cost是10（因为现在木料长度为10），然后切4米处，那么cost变成10+8（因为8是现在切的时候木料的长度）。然后切7米处，cost变成10+8+6，那么这种切法总共的cost是24。 

<img src="/Users/arthur/Library/Application Support/typora-user-images/image-20200511210132855.png" alt="image-20200511210132855" style="zoom:50%;" />



**Clarification:** The inputs are length of woods and the position of cut, and the output should be the minimum total cost to cut the stick into the defined pieces.

**Assumption:** Null

**Result:**  

**Base case:** 

<img src="/Users/arthur/Library/Application Support/typora-user-images/image-20200511210446405.png" alt="image-20200511210446405" style="zoom:50%;" />

<img src="/Users/arthur/Library/Application Support/typora-user-images/image-20200511210508870.png" alt="image-20200511210508870" style="zoom:50%;" />

**Induction rule:** 

<img src="/Users/arthur/Library/Application Support/typora-user-images/image-20200511210658525.png" alt="image-20200511210658525" style="zoom:50%;" />

<img src="/Users/arthur/Library/Application Support/typora-user-images/image-20200511210714801.png" alt="image-20200511210714801" style="zoom:50%;" />

**Test:** 

L = 10, A = {2, 4, 7}, the minimum total cost is 10 + 4 + 6 = 20 (cut at 4 first then cut at 2 and cut at 7).

```java
public class Solution {
  public int minCost(int[] cuts, int length) {
    // Assumptions: cuts is not null, length >= 0, all cuts are valid numbers.
    // First we need to pad the original array at leftmost and rightmost position.
    int[] helper = new int[cuts.length + 2]; // add head and tail
    helper[0] = 0;
    for (int i = 0; i < cuts.length; i++) {
      helper[i + 1] = cuts[i];
    }
    helper[helper.length - 1] = length;

    // M[i][j]: minCost[i][j], the min cost of cutting the partition(i, j).
    int[][] M = new int[helper.length][helper.length];
    for (int j = 1; j < helper.length; j++) {
      for (int i = j - 1; i >= 0; i--) {
        if (i + 1 == j) {
          M[i][j] = 0;
        }
        else {
          M[i][j] = Integer.MAX_VALUE;
          for (int k = i + 1; k < j; k++) {
            M[i][j] = Math.min(M[i][j], M[i][k] + M[k][j]);
          }
          M[i][j] += helper[j] - helper[i];
        }
      }
    }
    return M[0][helper.length - 1];
  }
}
```

|          Time Complexity          |    Space Complexity     |
| :-------------------------------: | :---------------------: |
|        O(n^2 * n) = O(n^3)        |         O(n^2)          |
| 三个for loop循环一遍；每次循环是n | 填满2D M[i] [j]的matrix |





### 657. Can I Win II

There is an array of positive integers, in which each integer represents a piece of Pizza’s size, you and your friend take turns to pick pizza from either end of the array.  Your friend follows a simple strategy: He will always pick the larger one he could get during his turn. The winner is the one who gets the larger total sum of all pizza. Return the max amount of pizza you can get.

**Clarification:** The input is an array of integer represents a piece of pizza’s size, and the output should be the maximum amount of pizza you can get. 

**Assumption:** If during your friend's turn, the leftmost pizza has the same size as the rightmost pizza, he will pick the **rightmost** one.

**Result:**  Firstly we should check the corner case: if mums == null || noms.length == 0, we should return 0.

**Base case:** 

a. 1 piece of pizza M[i] [i] = input[i]

b. 2 piece of pizza M[i] [i + 1] = max{input[i], input[i + 1]}

<img src="/Users/arthur/Library/Application Support/typora-user-images/image-20200511220402275.png" alt="image-20200511220402275" style="zoom:50%;" />

**Induction rule:** 



**Test:** 

Input: [2,1,100,3]

Output: 102

Explanation: To win the game, you pick 2 first, then your friend will pick either 3, after that you could pick 100. In the end you could get 2 + 100 = 102, while your friend could only get 1 + 3 = 4.

```java
public class Solution {
  public int canWin(int[] nums) {
    if (nums == null || nums.length == 0) {
      return 0;
    }

    // M[i][j]: max possible total from pieces i to j
    int[][] M = new int[nums.length][nums.length];
    for (int j = 0; j < nums.length; j++) {
      for (int i = j; i >= 0; i--) {
        if (i == j) { // only 1 piece left
          M[i][j] = nums[i];
        }
        else if (i + 1 == j){ // 2 pieces left
          M[i][j] = Math.max(nums[i], nums[j]);
        }
        else {
          // take i
          int left = nums[i + 1] > nums[j]? nums[i] + M[i + 2][j] : nums[i] + M[i + 1][j - 1];
          // take j
          int right = nums[i] > nums[j - 1]? nums[j] + M[i + 1][j - 1] : nums[j] + M[i][j - 2];
          M[i][j] = Math.max(left, right);
        }
      }
    }
    return M[0][nums.length - 1];
  }
}
```

|          Time Complexity          |    Space Complexity     |
| :-------------------------------: | :---------------------: |
|              O(n^2)               |          O(mn)          |
| 两个for loop循环一遍；每次循环是n | 填满2D M[i] [j]的matrix |